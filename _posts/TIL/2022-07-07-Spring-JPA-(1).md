---
title: "Spring (8) JPA란?"
categories:
    - TIL
tags:
    - CS
    - Spring
    - Backend
    - JPA
---

# 1. JPA란?

## 1) SQL 중심적인 개발의 문제점

### 객체 지향 언어와의 괴리

개발은 객체 지향 언어, DB는 관계형 DB가 주도권을 잡고 있는 시대

그러나 ***관계형 DB는 데이터를 잘 정규화해서 보관하는 것, 객체 지향은 필드와 메서드 들을 잘 묶어서 캡슐화해 쓰는게 목표***이다.

- 정규화 : 테이블 간에 중복을 최소화하게 데이터를 구조화하는 프로세스

DB는 SQL만 알아듣기 때문에 결국 객체 지향적으로 설계한 어떠한 데이터든, DB에 집어 넣기 위해서는 쿼리를 하나하나 짜야한다.

- 이를테면, CRUD 모두 설계하고, 자바 객체와 SQL간의 전환 코드 작성
- 객체를 만들어 놓고, 이에 맞게 쿼리를 다 짜놨더라도, 필드를 하나라도 추가해야하면 또 하나하나 쿼리를 전부 수정해야하는 경우가 발생한다.

→ SQL 중심적인 개발이 강제된다. ***서로 전혀 다른 것이다보니 연결하는데 문제***가 많이 생기는 것이다.

### 객체와 관계형 데이터베이스의 차이와 문제점

여러 차이가 있고, 이러한 각각의 차이에 의해 문제가 발생한다.

1. 상속

상속 관계를 그나마 보여줄 수 있는 것이 Table 슈퍼타입 서브타입 관계라는 DB 논리 모델이다. 이를 예로 들어 생각해보자.

![Untitled](https://gonnnnn.github.io/image/TIL/0707(1).png)                                   

위와 같은 자료를 저장하는 것을 생각해보자. ***Album, movie, book은 item을 상속한다***.

이렇게 상속 관계를 갖는 모델을 

- 저장할 때
    - ***Item table에도, 자식 table에도 필드를 insert하는 쿼리를 모두 만들어줘야 한다는 문제***가 잇다.
- 조회할 때
    - 부모와 자식 관계에 있는 객체에 대응하는 table을 join한 후, 데이터를 가져오고, ***부모와 자식에게 대응하는 필드를 구분하여, 하나하나 넣어줘야한다***.

단순하게 말하면, 쿼리문을 모든 경우에 대해 하나 하나 작성해 줘야하다보니 경우의 수가 너무 늘어나버린다는 것

1. 연관 관계

객체는 참조를 사용해 연관 관계에 있는 다른 객체를 가져올 수 있다.

- ex) get 함수

테이블은 외래 키(foreign key)를 사용한다.

- ex) JOIN ON M.TEAM_ID = T.TEAM_ID

![Untitled](https://gonnnnn.github.io/image/TIL/0707(2).png)                                       

→ 객체는 Team에서 Member로 갈 수 있는 참조가 없지만, ***테이블은*** TEAM, MEMBER ***쌍방향으로 Join이 가능***하다는 점을 확인하자

연관 관계 차이에 의해서는 어떤 문제가 발생할 수 있을까?

보통 객체는 DB 구조를 바탕으로 설계된다고 한다. 위의 경우를 예시로 보면

```java
class Member {
	string id;
	Team team;
	String username;

	Team getTeam() {
		return team;
	}
}

class Team {
	Long id;
	String name;
}
```

정도로 객체를 설계할 수 있겠다. 물론 Member에 team_id 필드를 그냥 넣어도 되겠지만, 조금 더 객체지향스러운 설계를 하기 위해 참조값을 갖도록 했다고 하자.

- 저장할 때
    - 조금 귀찮지만 `member.getTeam().getId();`등을 이용해서라도 필요한 값은 다 가져올 수 있으며,
    - `INSERT INTO MEMBER(MEMBER_ID, TEAM_ID, USERNAME) VALUES …`와 같은 형식으로 하나 하나 넣어주기만 하면 된다. 귀찮지만 복잡하지는 않다.
- 조회할 때
    - Member 객체는 자신이 속한 team 객체의 참조값을(못해도 id 값을) 필드로 갖고있다. 소속한 team의 객체도 당연히 만들어줘야한다.
    - Member, Team table을 ***join한 후, 모든 data를 먼저 긁어오고***
    - Member, Team ***데이터를 하나 하나 구분하고*** 객체에 ***하나 하나 넣어주며***
    - 마지막으로 Member 객체의 team 필드에 Team 객체 주소값을 넣어줌으로써(***연관 관계를 기입해줌으로써***) 마무리된다.

이게 너무 귀찮으니, MemberTeam과 같이 조회용 클래스를 만들어서 긁어온 데이터를 구분하는 과정을 생략하고 그냥 때려 박는 식으로 해결했다고 한다.

1. 객체 그래프 탐색

2번에 이어지는 문제이다.

객체는 자유롭게 객체 그래프를 탐색할 수 있어야 한다.

- 위의 경우 `member.getTeam()`으로 자유롭게 team에 접근할 수 있어야한다는 뜻

***그러나, get함수가 있다고 해서, 무조건 해당 객체에 접근할 수 있을까?***

`아뉘!!@#@없다!@#!!!!` ***접근 가능 여부, 탐색 가능 범위는 처음 실행하는 SQL에 따라 달라진다.*** 왜why?? 무슨 뜻일까?

- 위의 경우에서 다음과 같은 관계를 추가해보자. Member가 order라는 객체 참조값을 추가적으로 갖는 경우이다.

```java
class Member {
	string id;
	Team team;
	String username;
	Order order;

	Team getTeam() {
		return team;
	}

	Order getOrder() {
		return order;
	}
}
```

- 이 때 JOIN ON M.TEAM_ID = T.TEAM_ID와 같은 쿼리를 실행하고, 어찌저찌해서 이에 맞게 객체가 생성되었다고 하자.
- 이 경우, `getOrder` ***메서드가 class 내부에 분명 존재하지만***, 해당 메서드는 실제 order 객체를 반환하지 않고 ***null을 반환하게 된다. 당연하다. 애초에 DB에서 order관련 정보는 가져오지 않았기 때문이다.***

코드를 하나 하나 까봐야하는 경우가 발생한다. entity에 대한 신뢰 문제가 발생할 수도 있다는 것이다. ***다른 개발자가 코드를 짜놨더라도, 실제 쿼리를 어떻게 날렸고, 데이터를 어떻게 조립했는지를 직접 확인하지 않는 이상 신뢰할 수가 없게 되는 것이다.***

그렇다고 모든 객체를 미리 로드할 수는 없다. `getMember`, `getMemberWithTeam`, `getMemberWithOrderWithTeam`과 같이 가능한 쿼리에 대응하는 메서드를 하나 하나 만들며 행복하게 대응하는 방법으로 해결했다고도 한다.

1. 비교 문제

같은 데이터를 조회하는 쿼리를 두번 날리고, 다른 객체로 저장하면 당연히 메모리에서 다른 위치에 존재하는 다른 객체로 저장된다.

같은 데이터이지만 다른 객체인 것이다.

객체답게 모델링 할 수록 매핑 작업만 늘어난다. 오히려 SQL에 맞춰서 객체를 데이터를 그냥 전달하는 요소로만 사용할 수 밖에 없었다.

### ㅠㅠ

개발자들은 많은 고민을 했다. 더 쉽게 할 수 있는 방법은 없을까?

여기서 주목해야할 것은 자바 컬렉션

자바 컬렉션은 특별한 쿼리문을 필요로 하지 않고, add, get 메소드를 통해 연관 관계에 있는 것들을 쉽게 가져올 수 있다.

이를 이용한 전체적인 혁신이 시작된다.

## 2) JPA 소개

### JPA란

- Java Persistence API
- 자바 진영의 ORM 기술 표준
    - Object-relational mapping(객체와 관계형 데이터베이스의 매핑 기술)
    - 객체는 객체대로 설계하고, 관계형 DB는 관계형 DB대로 설계하고, 그 둘을 매핑!
- JPA는 인터페이스 모음. 실제 뭐 동작하는게 아니라 껍데기, 스펙의 모음이다.
- JPA 2.1 표준 명세를 구현한게
    - 하이버네이트, EclipseLink, DataNucleus가 있다. 대부분 하이버네이트 쓴다고

JPA는 자바 애플리케이션과 JDBC API 사이에서 활동한다. 애플리케이션이 JPA에게 명령하면 얘가 JDBC 호출

![Untitled](https://gonnnnn.github.io/image/TIL/0707(3).png)                                       

- JPA는 객체를 분석하고, 적절한 쿼리를 생성한 후 JDBC를 이용해 DB에 쿼리를 보낸다.
- 중요한건 ***패러다임의 불일치를 해결***한다는 것

### JPA를 왜 사용해야할까?

사실 이미 널리 쓰는 기술이라 왜 사용해야하는지 보다는 이 장점을 가능케하는 원리를 아는게 중요할 듯

생산성

- 저장 : `jpa.persist(member);` 끝!
- 수정 : `member.setName(”변경할 이름”);` 알아서 update 쿼리가 나간다.

유지보수

- 갑자기 table에 컬럼 하나 추가하라고 하면 쿼리를 다 바꿔야했다.
- ***JPA를 쓴다면, DB에 컬럼 추가, 객체에 필드 추가 하나하면 끝***!

패러다임의 불일치 해결

- 상속
    - Item-Album(부모-자식) 예시를 떠올려보자
    - `jpa.persist(album);` 하나만 실행시켜주면 ***알아서 두개의 쿼리를 생성***, table에 기입한다.
    - 조회도 ***알아서 join 쿼리를 날려*** 데이터를 가져온다.
- 연관관계, 객체 그래프 탐색
    - 원하는 데이터를 담는 객체를 반환 받을 수 있고, 이로부터 연관관계에 있는 다른 객체도 참조 가능
    - `Member member = jpa.find(Member.class, memberId);`
    - `Team team = member.getTeam();`
    - JPA는 지연로딩이라는 기능이 있어서, 객체를 조회, 사용하는 시점에 SQL이 나가 데이터가 채워진다고 한다. ***어쨋든, 가져오는 객체들을 믿을 수 있다는 것이다!***
- 비교하기
    - 같은 기준을 가지고 두번 객체를 가져와도 두 객체가 같음을 보장한다.
    - ***동일한 트랜잭션에서는 조회한 엔티티가 같음을 보장***한다.

### JPA의 성능 최적화 기능

두 계층 사이에 중간 계층이 있다면, 이를 버퍼, 캐시로 사용할 수 있다. CPU, RAM 구조만 생각해도 그렇다. JPA도 이런 기능을 할 수 있다.

1. 1차 캐시와 동일성(identity) 보장
    - 같은 트랜재션 안에서는 같은 엔티티를 반환한다. 같은 member를 두번 조회하면 실제로 같은 객체를 얻게 된다!
    - DB isolation level이 read commit이어도 애플리케이션에서 reapeatable read 보장. 무슨말인지는 모르겠다. 애플리케이션 단에서 뭘 좀 더 해줘서 isolation level을 한 단계 낮춰도 되는구나~ 정도로 알고만 넘어가라고
2. 트랜잭션을 지원하는 쓰기 지연 - INSERT
    - 쿼리문을 DB에 그때 그때 보내는게 아니라, 커밋하는 순간까지 비슷한 쿼리들을 모아뒀다가 한번에 보낸다.
    - JDBC BATCH라는 기능을 사용한다. 이게 여간 귀찮지만 JPA는 옵션 하나만 켜면 최적화시켜서 알아서 실행시켜준다.
3. 지연 로딩과 즉시 로딩
    - 지연 로딩: 객체가 실제 사용될 때 로딩
    - 즉시 로딩: JOIN SQL로 한번에 연관된 객체까지 미리 조회
    
    Member data를 가져올 때 연관 관계에 있는 Team data를 바로 가져오지 않고, 해당 데이터가 쓰일 때 가져오는 것이 지연 로딩인 것. JPA는 옵션을 켜고 끔으로써 지연 로딩과 즉시 로딩 사이에서 자유로운 전환이 가능하다.