---
title: "Spring (7) HTTP 캐시, 조건부 요청"
categories:
    - TIL
tags:
    - CS
    - Spring
    - Backend
---

# 8. HTTP 헤더 - 캐시와 조건부 요청

## 1) 캐시 기본 동작

- 첫 번째 request
    - 서버는 캐시가 유효한 시간 등을 헤더에 넣고 데이터를 보내준다.
- 웹 브라우저에서 캐시 저장소에 response 결과를 저장한다.
- 두 번째 request
    - 캐시를 뒤져서, 저장한게 있으면 그걸 가져온다!

캐시가 없다면, 계속 네트워크를 통해서 같은 데이터를 다운로드 받아야한다.

느려지고 비싸진다 ㅠㅠ

- 세 번째 request. 캐시를 확인해봤더니 유효 시간 초과됨을 가정
    - 기존 캐시를 지우고, 다시 모든 데이터를 response로 받아 캐시 저장소에 결과를 저장

## 2) 검증 헤더와 조건부 요청

캐시 유효 시간이 초과되어 서버에 다시 request하면 다음 두 가지 상황이 나타난다.

1. 그 사이에 서버에서 기존 데이터를 변경한 경우
2. 서버에서 기존 데이터를 변경하지 않은 경우

2***번의 경우 그냥 로컬 캐시를 쓰는게 낫다. 다만, 클라이언트의 데이터와 서버의 데이터가 같다는 사실을 확인할 방법이 필요하다. 그래서 나온게 검증 헤더와 조건부 요청!***

- 첫 번째 request
    - ***기존 예시에 Last-Modified(검증 헤더)라는 헤더를 추가해서 response를 준다.***
- 웹 브라우저에서는 캐시 저장소에 response 결과를 저장하고, 데이터 최종 수정일을 기록해 놓는다.
- 두 번째 request. 캐시 유효 시간 초과를 가정해보자
    - ***if-modified-since(조건부 요청)라는 헤더에 최종 수정일을 넣어 보내본다.***
    - 서버에서 최종 수정일을 확인한 후, 아직 그대로 써도 되는 경우면 가지고 있는 캐시를 그대로 쓰라는 “304 Not Modified”라는 response를 준다.
    - ***Last-Modified도 그대로 돌려보내고, Body는 아예 빼버린다.***
    - 네트워크 부하 감소!!
    - 브라우저는 response 확인 후, 캐시의 메타 정보(유효 시간 등등)캐시에서 데이터 가져와서 다시 쓴다.

아직 ETag 설명은 안했지만, 정리하자면

- 검증 헤더
    - 캐시 데이터와 서버 데이터가 같은지 검증하는 헤더
    - Last-Modified, ETag
- 조건부 요청 헤더
    - If-Modified-Since
        - Last-Modified에 사용
    - If-None-Match
        - ETag에 사용

검증 헤더와 조건부 요청 헤더를 조합해서 데이터를 새로 받아야하는지를 알 수 있을 것이다.

### Last-Modified, If-Modified-Since

- 데이터 미변경시 304 Not Modified 및 헤더 정보만 다시 전송
- 변경시(수정된게 맞으므로) 200 OK 및 해당 데이터와 헤더 정보 다시 전송
- 1초 미만 단위로 캐시 조정이 불가능
- 날자 기반 로직 사용
- 데이터를 수정해서 날짜가 다르지만, A→B→A로 수정해서 데이터 결과가 결국 똑같은 경우 비효율적
- 서버에서 별도의 캐시 로직을 관리하고 싶은 경우 비효율적
    - 스페이스나 주석처럼 크게 영향이 없는 변경이 있을 때 캐시를 유지하고 싶은 경우

### ETag, If-None-Match

- 데이터 미변경시 304 Not Modified 및 헤더 정보만 다시 전송
- 변경시(매치를 못했으므로) 200 OK 및 해당 데이터와 헤더 정보 다시 전송
- ETag(Entity Tag)
- 캐시용 데이터에 임의의 고유한 버전 이름을 달아둔다.
    - ex) ETag: “a3hkl2232lk”와 같이 hash code 사용
- 데이터가 변경되면 다른 hash를 생성해서 사용
- 진짜 단순하게 ETag만 보내서 같으면 유지, 다르면 다시 받기가 가능
- ***캐시 제어 로직을 서버에서 완전히 관리할 수 있게 된다.***
    - 애플리케이션 배포 주기에 맞추어 ETag를 모두 갱신하는 등의 행위 가능
- 클라이언트는 단순히 이 값을 서버에 제공

## 3) 캐시와 조건부 요청 관련 헤더

### 캐시 제어 헤더

- ***Cache-Control***
    - 캐시 지시어. 캐시 제어와 관련된다.
    - Cache-Control: max-age
        - 유효 시간, 초 단위 입력 가능
    - Cache-Control: no-cache
        - 데이터는 캐시해도 되지만, 항상 이 캐시를 쓰기 전에 이 데이터가 유요한지 원(origin) 서버에 요청해서 검증하고 사용하도록 하라는 것
    - Cache-Control: no-store
        - 데이터에 민감한 정보가 있으므로 저장하면 안됨(메모리에서 사용하고 최대한 빨리 삭제)
- Pragma
    - 캐시 제어
    - Pragma: no-cache
    - HTTP 1.0 하위 호환. 거의 사용 x
- Expires
    - 캐시 만료일을 정확한 날자로 지정해야함. expires: Mon, 01 Jan 1990 00:00:00 GMT
    - HTTP 1.0부터 사용
    - Cache-Control: max-age가 더 유연하다. 이와 함께 사용하면 Expires는 무시된다.
    
    ### 검증 헤더와 조건부 요청 헤더
    
    - 검증 헤더
        - ETag: “v1.0”, ETag: “asid234ksdf3”
        - Last-Modified: Thu, 04 Jun …
    - 조건부 요청 헤더
        - If-Match, If-None-Match ETag 값 사용
        - If-Modified-Since, If-Unmodified-Since: Last-Modified 값 사용
    
    ## 4) 프록시 캐시
    
    ### 프록시 캐시 서버
    
    - Origin 서버까지의 물리적 거리가 너무 멀어 데이터를 주고 받는데 너무 많은 시간이 걸릴 수 있다.
    - 이런 불편함을 해결하기 위해 중간에 프록시 캐시 서버를 설치한다. Origin 서버 대신, 더 가까운 프록시 캐시 서버에 접근해 데이터를 더 빨리 주고 받을 수 있다.
    - 이 곳에 저장되는 캐시를 public 캐시, 유저의 브라우저에 저장되는 것을 private 캐시라고 한다.
    
    ### Cache-Control
    
    캐시 지시어 - 기타
    
    - Cache-Control: public
        - 응답이 public 캐시에 저장되어도 된다는 뜻
    - Cache-Control: private
        - 응답이 해당 사용자만을 위한 것, private 캐시에 저장해야 함(기본값)
    - Cache-Control: s-maxage
        - 프록시 캐시에만 적용되는 max-age
    - Age: 60 (HTTP 헤더)
        - Origin 서버에서 응답 후 프록시 캐시 내에 머문 시간. 그냥 이런게 있다는 것 정도만 알아보자
    
    ## 5) 캐시 무효화
    
    ### Cache-Control
    
    브라우저들이 캐시 저장하지 말라고 해도 Get 요청 같은거면 임의로 캐시로 저장해버리기도 한다고 한다. 사용자 통장 잔고같은 정보는 절대 캐시에 저장하면 안될 것이다!!
    
    ***확실히 캐시 무효화를***  하기 위해서는 아래 것들을 다 넣으면 보통 확실히 대응이 된다.
    
    - Cache-Control: no-cache, no-store, ***must-revalidate***
        - 앞의 두개는 위에서 알아봤다. must-revalidate이 뭘까?
        - ***캐시 만료 후 최초 조회시 원 서버에 검증해야한다***는 뜻의 지시어이다.
        - 원 서버 접근 실피시 반드시 오류가 발생해야한다. 504
        - 다만 캐시 유효시간이라면 캐시를 사용한다.
    - Pragma: no-cache
        - HTTP 1.0 하위 호환
    
    ### no-cache vs must-revalidate?
    
    no-cache만 해도 원 서버에 항상 검증하고 사용하는건데 왜 must-revalidate가 필요할까? 다음과 같은 상황을 들여다보자
    
    - ETag과 no-cache를 포함하는 request를 보냈다고 하자.
        - 브라우저 → 프록시 캐시 서버 → 원서버 → 프록시 캐시 서버 → 브라우저 의 흐름으로 요청/응답이 전달될 것이다.
    - 어쩌다보니 프록시 캐시 서버와 원 서버 사이의 네트워크 단절이 순간적으로 일어나 위 요청이 원 서버까지 가지 못했다고 하자.
    
    no-cache의 경우
    
    - 이 경우 프록시 캐시 서버의 경우, 옛날 데이터라도 보여주기, 장애를 그대로 알려주기 등 다양한 응답을 하도록 설정할 수 있다.
    - 원 서버에 검증하기를 일단 요청하는 방법인 것이다.
    
    must-revalidate의 경우
    
    - 504 오류가 난다. 원 서버에서 검증이 안되면 절대 캐시를 다시 사용할 수 없도록 하는 것이다.
    - 돈과 같은 중요한 문제에 연결된 경우 적용해볼 수 있겠다. 계좌 이체를 한 후 다시 내역을 확인하는데 내역이 보이지 않는다면 혼란에 빠질 것이다.