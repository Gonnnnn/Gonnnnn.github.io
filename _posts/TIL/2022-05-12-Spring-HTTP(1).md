---
title: "Spring (4) 인터넷 네트워크, URI, 웹 브라우저 요청 흐름 "
categories:
    - TIL
tags:
    - CS
    - Spring
    - Backend
---
진짜 매우 매우 매우 간단하게 알아보자

# 1. 인터넷 네트워크

## 1) IP(인터넷 프로토콜)

특정 ***IP Address***에 ***Packet***이라는 통신 단위로 데이터를 전달하기 위한 규칙

Packet에 출발지 IP, 목적지 IP, 기타 다른 것들을 넣고 던져주면, 여러 길을 거쳐 규칙에 따라 전달되는 것

### 한계점

- 비연결성
    - 패킷을 받을 대상이 없거나 서비스 불능이어도 그냥 전송한다
- 비신뢰성
    - 중간에 패킷이 사라질 수도 있지 않는가? 또한 순서대로 오지 않을 수도 있지 않나?
- 프로그램 구분
    - 같은 IP를 사용하는 서버에서 통신하는 애플리케이션이 둘 이상이면??

이를 해결하는게 TCP이다!

## 2) TCP, UDP

### 인터넷 프로토콜 스택의 4계층

애플리케이션 계층 - HTTP, FTP

전송 계층 - TCP, UDP

인터넷 계층 - IP

네트워크 인터페이스 계층

- 프로그램이 메시지를 socket 라이브러리를 통해서 OS 계층에 넘긴다.
- OS 계층에서는 Hello라는 메세지에다 TCP 정보(녹색)를 입힌다.
- IP 관련 데이터(노란색)를 또 포함시킨다.
- 그 후 LAN 카드를 통해서 나갈 때 Ethernet Frame이라는 것이 또 씌워져서 나간다.

- TCP 세그먼트가 추가되면서 위의 한계점들을 극복한다.

### TCP 특징

TCP는 전송 제어 프로토콜(Transmission Control Protocol)이다. 다양한 기능들이 있는데 일단 아래 정도만 알아두도록 하자.

***연결지향 - TCP 3 way handshake***
- 쟤랑 나랑 연결이 되어있는지 먼저 확인하고 전송한다.
- SYN을 보내고, SYN+ACK을 받고, 그다음 ACK을 보내며 연결되었음을 확인하고 데이터를 전송한다. 요즘은 3번째 단계에서 데이터 같이 보내기도
- 참고로, 실제 연결된게 아니다. 옛날에는 어디 전화하면 중개소에서 그쪽 포트에 실제로 선을 꼽아주는 식이었다고 하는데, 이런식으로 정말 연결되었다기 보다는 ”아 이 친구가 응답을 하네? 연결됐나보다“ 정도로 그냥 가정하는 수준이다. 가상 연결이라고 한다. 논리적으로 연결된거일 뿐이다. 전용 랜선이 보장되었다거나 하는게 아니다.

***데이터 전달 보증***

- 패킷이 중간에 누락되면 그걸 알 수 있다.
- 데이터 전송에서 잘 받았으면, 잘 받았다고 응답해준다.

***순서 보장***

- 패킷1,2,3을 순서대로 보냈는데, 1,3,2로 받았다고 하자.
- 기본적으로는 다 버리고 패킷2부터 다시 보내라고 서버가 클라이언트에게 요청한다. 물론 최적화를 어떻게 하느냐에 따라 다르지만 잘못왔으면 그 순서부터 다시 보내게 한다.
- 전송 제어 정보, 순서 정보, 검증 정보 등이 추가 되었기에 가능한 것!

### UDP 특징

사용자 데이터그램 프로토콜(User Datagram Protocol)

- 기능이 없다. TCP가 보장하는 것들을 보장하지도 않는다.
- IP와 거의 같지만, 거기에 PORT, 체크섬이라는게 추가가 된다. 물론 PORT 정보는 TCP에도 있다.
    - PORT라는건 내 IP로 여러 패킷이 왔을 때, 그거 배분하는 그런 공간 정도로 생각하면 된다. 아래에서 더 알아본다.
    - 내 컴퓨터로 음악도 듣고 게임도 하고 하는데 패킷이 오면 어디로 가야하는지 어떻게 알 수 있을가? PORT를 확인해서 알 수 있는 것이다!
- ***TCP는 다 좋은데 시간이 좀 걸리고, 최적화도 어렵다. 구축이 다 되어있어버려서***
- ***여기서 뭘 손대고 싶으면 UDP에 손을 대는 것이다. 내가 애플리케이션 레벨에서 뭘 만들어내면 된다. 마치 하얀 도화지같은 것***

## 3) Port

클라이언트가 게임도하고 화상통화도 하고 웹툰도 보고 있다면 한번에 여러 개의 서버와 통신해야한다.

내 IP로 패킷들이 날아올텐데 대체 위의 것들 중 어떤 것에 관한 패킷인지 알 방도가 없다.

***PORT를 도입하기 전까진!***

IP는 목적지, 출발지를 찾는 것이고, PORT는 그 목적/출발지 서버에서 돌아가는 애플리케이션을 구분하는 것으로 보면 된다.

- 0~65535까지 할당 가능
- 0~1023은 잘 알려진 포트라 건들지 말자

## 4) DNS

IP는 기억하기도 어렵고, 변경될 여지가 있다.

DNS는 도메인 네임 시스템(Domain Name System)으로 ***전화번호부*** 같은 것이다

- 클라이언트가 DNS 서버에 도메인 명을 물어보면, IP를 응답으로 건내준다
- 이걸 가지고 해당 서버에 패킷을 보낼 수 있는 것!

# 2. URI와 웹 브라우저 요청 흐름

## 1) URI(Uniform Resource Identifier)

뜻을 풀어보면 자원을 식별하는 통일된 방식 정도이다. 자원은 URI로 식별할 수 있는 모든, 정말 모든 것을 의미한다. 교통 정보부터 특정 파일까지

URI에는 URL, URN이 포함되며 URN을 잘 쓰지 않아 보통 URI=URL로 말한다.

- URL (Resource ***Locator***): 리소스가 있는 위치를 지정. 철수는 여기 있다!
- URN (Resource ***Name***): 리소스에 이름을 부여. 철수 그 자체!
    - 이름은 변하지 않는다. ex) urn:isbn:513218945
    - URN만으로 리소스를 찾을 수 있는 방법이 보편화 되어있지는 않는다.

### URL

- scheme :// [userinfo@] host[:port] [/path] [?query] [#fragment] 의 구조를 갖는다.

Scheme

- 주로 프로토콜 사용. http, https 등
- http는 주로 80 포트, https는 443 포트를 주로 사용해서 얘들 쓸 땐 포트 생략 가능해서 우리가 보통 port 번호를 보지 못했던 것이다.

userinfo

- 거의 안쓴다. URL에 사용자 정보를 포함해서 인증해야할 때 쓴다.

host

- domain명이나 ip주소를 직접 입력할 수 있다.

port

- 일반적으로 생략

path

- 리로스가 있는 경로이다. 보통 계층적 구조로 되어있다. 사실 지 맘대로 해도 된다 ㅋㅋ

query

- key=value의 형태로 들어간다
- ?로 시작하고, &으로 추가할 수 있다. ?key1=value1&key2=value2
- 공식적으로는 query인데 query parameter, query string으로 부른다. 웹서버에 제공하는 파라미터, 문자이기 때문

fragment

- html 내부에서 중간 북마크로 이동하고 싶을 때 쓰는데, 서버에 전송하는 정보는 아니다.

## 2) 웹 브라우저 요청 흐름

- DNS 조회 후 IP 주소를 받는다.
- 웹 브라우저가 HTTP 요청 메시지를 생성한다.
    - GET /search?q=hello&hl=ko HTTP1.1
    - Host: [www.google.com](http://www.google.com) 등..
- 우리는 이제 IP와 PORT정보를 안다. SOCKET 라이브러리를 통해서 TCP 3way handshake한번 해주고, 연결할 준비 딱 완료한다!
- 그리고 TCP/IP단에서 패킷을 추가로 씌워주고, 전송한다.
- 그 후 수많은 인터넷 노드를 거쳐서 해당 서버에 전달된다.
- 서버에서는 패킷을 다 까서 버리고 HTTP 요청 메시지를 해석을 한다.
- 그 후 HTTP 응답 메시지를 다시 보내준다. HTTP 버젼, Content-Type 등등이 포함된다. 나중에 또 본다.
- 응답에서 내용을 웹브라우져가 열고, 렌더링해준다.